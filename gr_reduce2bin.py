import argparse
import subprocess

def apply_minimax_convolution(w1, w2):
    """Возвращает максимальное значение веса для минимакс-свертки."""
    return max(w1, w2)

def normalize_weights(edges):
    """Нормализует веса рёбер в диапазон [0, 1]."""
    weights = [weight for _, _, weight in edges]
    min_weight = min(weights)
    max_weight = max(weights)
    if max_weight == min_weight:
        return [(u, v, 1) for u, v, _ in edges]  # Если все веса одинаковы, нормализуем до 1
    return [(u, v, (weight - min_weight) / (max_weight - min_weight)) for u, v, weight in edges]

def apply_multiplicative_convolution(w1, w2):
    """Возвращает произведение весов для мультипликативной свертки."""
    return w1 * w2

def apply_lambda_convolution(w1, w2, lambd=0.5):
    """Возвращает результат свертки с параметром λ."""
    return lambd * w1 + (1 - lambd) * w2

def process_graph_files(file1, file2, output_minimax, output_multiplicative, output_lambda, lambd=0.5):
    header_line = None
    minimax_edges = []
    multiplicative_edges = []
    lambda_edges = []

    with open(file1, 'r') as f1, open(file2, 'r') as f2:
        for line1, line2 in zip(f1, f2):
            # Если строка начинается с 'p', сохраняем ее как заголовок для всех файлов
            if line1.startswith('p'):
                header_line = line1.strip()
                continue
            # Пропуск комментариев
            if line1.startswith('c') or line2.startswith('c'):
                continue

            # Разделяем строки на вершины и веса
            u1, v1, w1 = map(float, line1.split()[1:])
            u2, v2, w2 = map(float, line2.split()[1:])

            # Проверяем, что рёбра идентичны
            assert (u1, v1) == (u2, v2), "Рёбра в файлах не совпадают"

            # Применяем свертки
            minimax_weight = apply_minimax_convolution(w1, w2)
            multiplicative_weight = apply_multiplicative_convolution(w1, w2)
            lambda_weight = apply_lambda_convolution(w1, w2, lambd)

            # Сохраняем рёбра для последующей нормализации минимакс-свертки
            minimax_edges.append((int(u1), int(v1), minimax_weight))
            multiplicative_edges.append((int(u1), int(v1), multiplicative_weight))
            lambda_edges.append((int(u1), int(v1), lambda_weight))

    # Нормализация минимакс-свертки
    minimax_edges = normalize_weights(minimax_edges)

    # Записываем результаты в файлы с добавлением заголовка
    with open(output_minimax, 'w') as out_minimax, \
         open(output_multiplicative, 'w') as out_multiplicative, \
         open(output_lambda, 'w') as out_lambda:
             
        out_minimax.write("c This file is generated by a script\n")
        out_multiplicative.write("c This file is generated by a script\n")
        out_lambda.write("c This file is generated by a script\n")
        
        if header_line:
            out_minimax.write(header_line + "\n")
            out_multiplicative.write(header_line + "\n")
            out_lambda.write(header_line + "\n")

        for u, v, weight in minimax_edges:
            out_minimax.write(f"a {u} {v} {weight}\n")
        for u, v, weight in multiplicative_edges:
            out_multiplicative.write(f"a {u} {v} {weight}\n")
        for u, v, weight in lambda_edges:
            out_lambda.write(f"a {u} {v} {weight}\n")

    # Выполняем ConvertGraph для каждого выходного файла и затем GenerateODPairs
    bin_minimax = convert_graph(output_minimax)
    bin_multiplicative = convert_graph(output_multiplicative)
    bin_lambda = convert_graph(output_lambda)

    generate_od_pairs(bin_minimax)
    generate_od_pairs(bin_multiplicative)
    generate_od_pairs(bin_lambda)

def convert_graph(filename):
    """Выполняет команду ConvertGraph для указанного файла .gr и возвращает имя бинарного файла .bin."""
    t_name = filename.replace(".dist.gr","")
    print(t_name)
    out_name = t_name + "_graph"
    command = [
        "ConvertGraph", "-s", "dimacs", "-d", "binary",
        "-a", "capacity", "coordinate", "free_flow_speed", "lat_lng", "length",
        "-i", t_name, "-o", out_name
    ]
    try:
        subprocess.run(command, check=True)
        print(f"Успешно выполнено ConvertGraph для {filename}")
    except subprocess.CalledProcessError:
        print(f"Ошибка при выполнении ConvertGraph для {filename}")
    return out_name + ".gr.bin"

def generate_od_pairs(filename):
    """Выполняет команду GenerateODPairs для указанного бинарного графа .bin."""
    t_name = filename.replace(".gr.bin","")
    out_name = t_name + "_graph_pairs"
    command = [
        "GenerateODPairs", "-n", "100", "-r", "1", "-d", "10", "-geom",
        "-g", filename, "-o", out_name
    ]
    try:
        subprocess.run(command, check=True)
        print(f"Успешно выполнено GenerateODPairs для {filename}")
    except subprocess.CalledProcessError:
        print(f"Ошибка при выполнении GenerateODPairs для {filename}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Свертка двух графов с разными методами.")
    parser.add_argument("file1", type=str, help="Путь к первому .gr файлу.")
    parser.add_argument("file2", type=str, help="Путь ко второму .gr файлу.")
    parser.add_argument("--output_minimax", type=str, default="output_minimax.gr", help="Имя выходного файла для минимакс-свертки.")
    parser.add_argument("--output_multiplicative", type=str, default="output_multiplicative.gr", help="Имя выходного файла для мультипликативной свертки.")
    parser.add_argument("--output_lambda", type=str, default="output_lambda.gr", help="Имя выходного файла для свертки с параметром лямбда.")
    parser.add_argument("--lambda_value", type=float, default=0.5, help="Значение параметра лямбда для свертки с параметром лямбда.")

    args = parser.parse_args()

    process_graph_files(
        args.file1, 
        args.file2, 
        args.output_minimax, 
        args.output_multiplicative, 
        args.output_lambda, 
        args.lambda_value
    )
